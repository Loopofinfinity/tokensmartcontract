// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract LoopOfInfinity is ReentrancyGuard {
    using SafeMath for uint256;

    bool private locked; // boolean variable to prevent reentrancy attacks

    // NOTE: While the contract uses SafeMath to prevent integer overflow/underflow, it is still possible that the balanceOf and totalSupply variables could overflow or underflow if the contract is used for a long period of time. Please exercise caution and monitor the contract for any unexpected behavior.

    // Token Information
    string public constant name = "Loop Of Infinity"; // Name of the token
    string public constant symbol = "LOI"; // Symbol of the token
    uint8 public constant decimals = 18; // Number of decimal places
    uint256 public constant initialSupply = 50 * 10**9 * 10**uint256(decimals); // Initial token supply
    uint256 public constant maxSupply = 50 * 10**9 * 10**uint256(decimals); // Maximum token supply
    uint256 public totalSupply; // current total supply of the token

    // Balances and allowances
    mapping(address => uint256) public balanceOf; // Mapping of token balances
    mapping(address => mapping(address => uint256)) public allowance; // Mapping of token allowances
    mapping(address => bool) authorized;

    // Contract owners and configuration
    address public owner; // Current contract owner
    address public pendingOwner; // Pending contract owner
    address public multiSigWallet; // MultiSig wallet for managing the contract
    uint256 public antiWhaleLimit; // Anti-whale limit for maximum token holdings
    uint256 public numRequiredConfirmations; // Number of required confirmations for multiSig transactions
    
    // Declare the events
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event AntiWhaleLimitChanged(uint256 indexed oldLimit, uint256 indexed newLimit);
    event MaxSupplyChanged(uint256 maxSupply);
    event NumRequiredConfirmationsChanged(uint256 oldNum, uint256 newNum);
    event AntiWhaleLimitSet(uint256 newLimit);
    event AuthorizedAdded(address indexed authorizedAddress);
    event AuthorizedRemoved(address indexed authorizedAddress);
    event CriticalDataModified(address indexed user, uint256 newData);
    
    // State variables
    uint256 public criticalData; // State variable to hold critical data
    bool private locked; // Boolean variable to prevent reentrancy attacks

    // @dev Modifier to restrict access to functions only to the contract owner
    modifier onlyOwner() {
        require(msg.sender == owner, "Only contract owner can call this function.");
        _;
    }
    
    modifier onlyAuthorized() {
        require(authorized[msg.sender], "Only authorized addresses can call this function.");
        _;
    }

    modifier mutex {
        require(!locked, "Function is locked");
        locked = true;
        _;
        locked = false;
    }

    function addAuthorized(address _address) public onlyOwner mutex {
        require(_address != address(0), "Invalid address");
        authorized[_address] = true;
        emit AuthorizedAdded(_address);
    }

    function removeAuthorized(address _address) public onlyOwner mutex {
        require(_address != address(0), "Invalid address");
        authorized[_address] = false;
        emit AuthorizedRemoved(_address);
    }

    function modifyCriticalData(uint256 _data) public onlyOwner {
    require(!locked, "Contract is locked");
    require(_data > 0, "Invalid data");
    
    // modify the critical data here
    emit CriticalDataModified(msg.sender, _data);
}

    constructor(address _multiSigWallet, uint256 _numRequiredConfirmations) {
        require(
            _multiSigWallet != address(0),
            "Invalid multi-sig wallet address"
        );
        require(
            _numRequiredConfirmations > 0,
            "Number of required confirmations must be greater than zero"
        );

        owner = msg.sender;
        multiSigWallet = _multiSigWallet;
        numRequiredConfirmations = _numRequiredConfirmations;
        totalSupply = initialSupply;
        balanceOf[msg.sender] = initialSupply;
        emit Transfer(address(0), msg.sender, initialSupply);

        // Set the initial anti-whale limit to 200 million tokens
        antiWhaleLimit = 200000000 * 10**decimals;
}

    // Declare the event
function setAntiWhaleLimit(uint256 _antiWhaleLimit) public onlyOwner {
    require(!locked, "Function is locked");
    locked = true;
    require(_antiWhaleLimit >= totalSupply, "Anti-whale limit cannot be lower than the current total supply");

    uint256 gasLimit = gasleft() - 20000; // Subtract a fixed gas cost of 20,000 for each operation in the function
    antiWhaleLimit = _antiWhaleLimit; // Update the value of antiWhaleLimit
    emit AntiWhaleLimitChanged(antiWhaleLimit, _antiWhaleLimit); // Emit the event

    locked = false;
    require(gasleft() > gasLimit, "Transaction ran out of gas"); // Ensure that there is enough gas left to complete the transaction
}

    // Declare the event
    function transferOwnership(address newOwner) external onlyOwner {
    require(newOwner != address(0), "New owner cannot be the zero address");

    locked = true; // Set locked variable to true

    address previousOwner = owner;
    owner = newOwner;

    // Emit the event
    emit OwnershipTransferred(previousOwner, newOwner);

    locked = false; // Set locked variable back to false
}

    // Declare the event
    function claimOwnership() public {
    require(pendingOwner != address(0), "Invalid pending owner address");
    require(msg.sender == pendingOwner, "Only pending owner can claim ownership");
    locked = true; // Set locked to true at the beginning
    address previousOwner = owner;
    owner = pendingOwner;
    pendingOwner = address(0);
    locked = false; // Set locked back to false at the end

    // Emit the event
    emit OwnershipTransferred(previousOwner, owner);
}

    // Declare the event
   function changeNumRequiredConfirmations(uint256 newNum) public onlyOwner nonReentrant {
    locked = true; // Set locked to true
    numRequiredConfirmations = newNum;
    emit NumRequiredConfirmationsChanged(numRequiredConfirmations);
    locked = false; // Set locked back to false
}

    function setNumRequiredConfirmations(uint newNum) public {
    require(newNum > 0, "New number of confirmations must be greater than zero");
    numRequiredConfirmations = newNum;

    // Emit the event
    emit NumRequiredConfirmationsChanged(
        numRequiredConfirmations,
        newNum
    );
}
    uint256 public maxTxAmount;

    // Declare the event
    function setMaxTxAmount(uint256 newMax) external onlyOwner {
        require(
            newMax > 0,
            "New maximum transaction amount must be greater than 0"
        );
        maxTxAmount = newMax;
    }

    modifier nonReentrant() {
        require(!locked, "Reentrancy detected");
        locked = true;
        _;
        locked = false;
    }

    // Declare the event
    function transfer(address _to, uint256 _value) public returns (bool success) {
    require(!preventReentrancy, "Reentrancy attack detected");
    require(_to != address(0), "Invalid address");
    require(_value > 0, "Invalid amount");

    uint256 senderBalance = balanceOf[msg.sender];
    require(senderBalance >= _value, "Insufficient balance");

    balanceOf[msg.sender] = senderBalance.sub(_value);
    balanceOf[_to] = balanceOf[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;
}

    function transfer(address _to, uint256 _value) public returns (bool) {
uint256 tax = 0;
if (isCentralizedExchange(_to)) {
tax = _value.mul(2).div(100);
_value = _value.sub(tax);
}

    balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
    balanceOf[_to] = balanceOf[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);

    if (tax > 0) {
        balanceOf[address(this)] = balanceOf[address(this)].add(tax);
        emit Transfer(msg.sender, address(this), tax);
    }

    locked = false; // set locked back to false after modifying state

    return true;
}

function isCentralizedExchange(address _address) internal view returns (bool) {
    require(!locked, "Reentrant call detected");
    // TODO: Implement logic to check if the given address is a centralized exchange
    return false;
}

// Calculate the required gas limit based on the current total supply
function calculateGasLimit(uint256 _value) public view returns (uint256) {
    uint256 totalSupply = totalSupply();
    uint256 requiredGas = 100000 + (totalSupply / 10000) * 10000;
    uint256 remainingGas = gasleft();
    if (remainingGas > requiredGas) {
        return requiredGas;
    } else {
        return remainingGas;

// Check for gas limit
require(msg.value >= calculateGasLimit(_value), "Insufficient gas");

        // Update balances
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}

fallback() external payable {
    revert("Fallback function not allowed");
